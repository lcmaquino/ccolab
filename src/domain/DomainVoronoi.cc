/**
 * @file DomainVoronoi.cc
 *
 *  Copyright 2022 Luiz C. M. de Aquino.
 * 
 *  This file is part of CCOLab.
 *
 *  CCOLab is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  CCOLab is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with CCOLab.  If not, see <https://www.gnu.org/licenses/>
 *
 */

/**
 * @author Luiz ClÃ¡udio Mesquita de Aquino (luiz.aquino@ufvjm.edu.br)
 * @brief
 * @version 1.0
 * @date 2022-05-18
 */
#include "DomainVoronoi.h"

DomainVoronoi::DomainVoronoi(Domain *domain, TreeModel **trees,
                             double *targetPerfusionFlow, int numberOfTrees,
                             double territoryWeigth)
    : DomainSubsets(domain, numberOfTrees) {
  _geometry = new Geometry(domain->dimension());
  _targetPerfusionFlow = targetPerfusionFlow;
  _territoryWeigth = territoryWeigth;
  setTrees(trees);
}

DomainVoronoi::~DomainVoronoi() {
  int i;
  if (_totalPoints > 0) {
    delete[] _pointTreeID;
    for (i = 0; i < _totalPoints; i++) {
      delete _points[i];
    }
    delete[] _points;
  }
}

void DomainVoronoi::setTrees(TreeModel **trees) {
  _trees = trees;
  extractReferencePoints();
}

void DomainVoronoi::setTerritoryWeigth(double territoryWeigth) {
  _territoryWeigth = territoryWeigth;
}

double DomainVoronoi::territoryWeigth() { return _territoryWeigth; }

void DomainVoronoi::extractReferencePoints() {
  int t, i, n;
  _totalPoints = 0;
  _currentNumberOfPoints = 0;

  for (t = 0; t < numberOfSubsets(); t++) {
    _totalPoints += _trees[t]->currentNumberOfSegments();
    //_totalPoints += _trees[t]->currentNumberOfTerminals();
  }

  if (_totalPoints > 0) {
    _points = new Point *[_totalPoints];
    _pointTreeID = new int[_totalPoints];
    for (t = 0; t < numberOfSubsets(); t++) {
      for (i = _trees[t]->begin(); i < _trees[t]->end(); i++) {
        //if(_trees[t]->isTerminal(i)) {
          _points[_currentNumberOfPoints] = new Point(domain()->dimension());
          *_points[_currentNumberOfPoints] = _trees[t]->distalPoint(i);
          _pointTreeID[_currentNumberOfPoints] = t;
          _currentNumberOfPoints++;
        //}
      }
    }
  } else {
    cout << "Oops! No segments in the trees." << endl;
    exit(1);
  }
}

double *DomainVoronoi::distanceFromTrees(Point point){
  int i;
  double minDistance = 1e10, d, *dist = new double [numberOfSubsets()];

  /* Initialize the distance vector dist. */
  for (i = 0; i < numberOfSubsets(); i++) {
    dist[i] = 1e10;
  }

  /* Get the minimum distance from the given point to each tree. */
  for (i = 0; i < _currentNumberOfPoints; i++) {
    d = _geometry->distance(point, *_points[i]);
    if (d < dist[_pointTreeID[i]]) {
      dist[_pointTreeID[i]] = d;
    }
  }

  return dist;
}

void DomainVoronoi::territory(string filename) {
  int i, j, minDistTree, subset[domain()->totalNumberOfPoints()], territory[numberOfSubsets()];
  double *dist;
  ofstream file;
  Point point;

  file.open(filename);
  for (i = 0; i < numberOfSubsets(); i++) {
    territory[i] = 0;
  }

  if (file.is_open()) {
    file << "SUBSET TERRITORY" << endl;
    i = 0;
    domain()->reset();
    while (domain()->hasAvailablePoint()) {
      point = domain()->point();
      dist = distanceFromTrees(point);
      minDistTree = 0;
      for(j = 0; j < numberOfSubsets(); j++) {
        if(dist[j] < dist[minDistTree]){
          minDistTree = j;
        }
      }

      subset[i] = minDistTree;
      territory[subset[i]] += 1;
      i++;
      delete[] dist;
    }

    domain()->reset();
    for (i = 0; i < numberOfSubsets(); i++) {
      file << i << " "
           << (100.0 * territory[i]) / domain()->totalNumberOfPoints() << endl;
    }

    file.close();
  } else {
    cout << "Unable to open: \"" << filename << "\"." << endl;
  }
}

void DomainVoronoi::diagram(string filename, double unit) {
  int i, subset[domain()->totalNumberOfPoints()], territory[numberOfSubsets()];
  ofstream file;
  Point point;
  double z;
  file.open(filename);
  for (i = 0; i < numberOfSubsets(); i++) {
    territory[i] = 0;
  }

  if (file.is_open()) {
    file << "# vtk DataFile Version 3.0" << endl;
    file << "Domain subsets generated by CCOLab" << endl;
    file << "ASCII" << endl;
    file << "DATASET POLYDATA" << endl;
    file << "POINTS " << domain()->totalNumberOfPoints() << " double" << endl;
    i = 0;
    domain()->reset();
    while (domain()->hasAvailablePoint()) {
      point = domain()->point();
      subset[i] = inSubset(point);
      territory[subset[i]] += 1;
      i++;
      z = domain()->dimension() == 2 ? 0.0 : point.z();
      file << point.x() * unit << " " << point.y() * unit << " " << z * unit
           << endl;
    }

    domain()->reset();
    file << endl;
    file << "VERTICES " << domain()->totalNumberOfPoints() << " "
         << 2 * domain()->totalNumberOfPoints() << endl;
    for (i = 0; i < domain()->totalNumberOfPoints(); i++) {
      file << "1 " << i << endl;
    }

    file << endl;
    file << "CELL_DATA " << domain()->totalNumberOfPoints() << endl;
    file << "SCALARS subset int" << endl;
    file << "LOOKUP_TABLE default" << endl;
    for (i = 0; i < domain()->totalNumberOfPoints(); i++) {
      file << subset[i] << endl;
    }

    file.close();

    for (i = 0; i < numberOfSubsets(); i++) {
      cout << i << " "
           << (100.0 * territory[i]) / domain()->totalNumberOfPoints() << endl;
    }
  } else {
    cout << "Unable to open: \"" << filename << "\"." << endl;
  }
}

void DomainVoronoi::referencePoints(string filename, double unit) {
  int i, t;
  ofstream file;
  Point point;
  double z;
  string delimiter = " ";
  file.open(filename);
  if (file.is_open()) {
    file << "x" << delimiter << "y" << delimiter << "z" << delimiter << "SUBSET"
         << endl;
    for (i = 0; i < _currentNumberOfPoints; i++) {
      point = *_points[i];
      z = domain()->dimension() == 2 ? 0.0 : point.z() * unit;
      file << point.x() * unit << delimiter << point.y() * unit << delimiter
           << z << delimiter << _pointTreeID[i] << endl;
    }

    file.close();
  } else {
    cout << "Unable to open: \"" << filename << "\"." << endl;
  }
}

int DomainVoronoi::inSubset(Point point) {
  int i, subset = 0, n;
  double d, *dist, dMax = -1.e10;
  bool checkTargetFlow = true;

  dist = distanceFromTrees(point);

  /* Get the maximum value in the vector dist. */
  for (i = 0; i < numberOfSubsets(); i++) {
    if (dist[i] > dMax) {
      dMax = dist[i];
    }
  }

  /**
   * Get the subset associated with the minimum value in the vector dist.
   * If this value is greater than or equal to the territory weigth times the
   * maximum distance, then the target perfusion flow will be checked.
   */
  subset = 0;
  for (i = 0; i < numberOfSubsets(); i++) {
    if (dist[i] <= dist[subset]) {
      subset = i;
      checkTargetFlow = dist[i] >= _territoryWeigth*dMax;
    }
  }

  /**
   * If the target perfusion flow has to be checked, then get the subset
   * associated with the minimum target perfusion flow.
   */
  if (checkTargetFlow) {
    subset = 0;
    for (i = 0; i < numberOfSubsets(); i++) {
      if (_targetPerfusionFlow[i] < _targetPerfusionFlow[subset]) {
        subset = i;
      }
    }
  }

  delete[] dist;

  return subset;
}
